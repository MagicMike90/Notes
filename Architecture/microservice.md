# Microservice notes

## Domain-drive design

It is very important to note that OOP is not only inheritance, interfaces, or anything else of the type. OOP's main ideas are as follows:

- Code alignment with the business
- Favoring of reuse
- Minimal coupling

three are more prominent for efficient microservices:

- Context maps: These are the communication paths between microservices with appropriate interactions between microservices teams. After the analysis of the areas are already defined, the team can choose to be dependent on another team for domain language.
- Anti-corruption layer (ACL): This is the function that translates foreign concepts for an internal model to provide loose coupling between the domains.
- Interchange context: This provides an environment for both teams and discusses the meaning of each foreign term and translates the languages of microservices.

## Independent deploy, update, scale and replace

### Update

- Never share libraries between microservices
- Strong delimitation of microservice domains
- Establish a client-server relationship between microservices
- Deploy in separate containers

### Scale

**The Scale Cube**: 3 axis

- x-axis: horizontal decomposition: with the same application server replicated n times in full and in a balanced order of 1/n.
- y-axis: functional decomposition: a verb or route is used by the balancer to identify where to go with the request.
- z-axis: data partitioning: is very similar to the x-axis when it comes to scalability structure, as it distributes exactly the same code on each server. The big difference is that each server responds to a specific subset of dat

## Communication

|              |       One-to-One        |             One-to-Many |
| ------------ | :---------------------: | ----------------------: |
| Synchronous  |    Request/response     |                       - |
| Asymchronous |      Notification       |        publish/subsribe |
|              | Request/ async response | publish/async responses |

### Synchronous

- HTTP
- TCP
- WebSockets
- Sockets
- RPC
- SOAP

### Asynchronous

For this approach, the message broker is just perfect. Some software applications appear a good choice for message brokers, such as RabbitMQ, ActiveMQ, ZeroMQ, Kafka, and Redis. Each of these options has its own peculiarities, some are faster, others are more resilient. Again, the business setting is going to determine which technology is used.

### Mobile vs web endpoints

Problems such as speed and weight information in the web world are not very common; we cannot say the same for the mobile world.

### Caching at the client level

request only passes to be processed on the backend, if really necessary. In other words, it tries to block direct access to the backend to requests that have already been implemented in the recent past.

### Throttling for your client

- Number of requests per minute from the same client
- Number of requests per second from the same client
- Number of requests per minute from the same client for similar information
- Number of requests per second for the same client for the same information

### Identification of an anemic domain

- The microservice cannot perform the tasks itself with only the data received
- The microservice needs to fetch data in more than one endpoint to perform a task
- The microservice does not have a self-sufficient entity model
- The microservice waits for the completion of a task in another microservice to follow up what you need to do
- The microservice needs to share resources with other external microservices; these resources can be cached to the sample database

If the microservice being developed is one of those items, then it can be a weak area. If a microservice has two or more characteristics of those listed, then it is definitely an anemic domain.

Anemic domains are very harmful to the microservices ecosystem, because they have a tendency to be multiplied in order to correct the technical debt generated by the deficiency in the composition of their respective domains.

### Fat domain - AAA (Authentication, Authorization, and Accounting

The division of this fat domain can be held in two parts; the first part is AAAService and the second is UserService. Another approach is the AAA responsibility for a gateway API. The functional scalability and features of implementation with these separate domains is much more interesting for the growth of the product as a whol

## Things to consider

Cost and scability:

- Programming languages
- Microservices frameworks
- Binary communication
- Message broker
- Caching tools
- Fail alert tools
- Locale proof performance

## Death Start

The Death Star is an anti-pattern where there is communication between the recursion microservices, and making progress becomes extremely complicated or expensive for a product.

## Message broker - Async communication between services

why not use this messaging for all types of communication between microservices?

The answer to this question is quite simple. A message bus is a physical component within the stack of microservices. It needs to be scaled just like any other physical component-based data storage and cache. This means that with a high-volume message, the synchronous mode of communication could be committed to an unwanted delay in the responses of the processes.

### Tools

- ActiveMQ
- RabbitMQ
- Kafka

#### Caching tools

- Memcached
  classic process of using cache, Memcached is simple and practical to use. The performance of Memcached is fully linked to the use of memory. If Memcached uses the disc to register any data, the performance is seriously compromised; moreover, Memcached does not have any record of disk capacity and always depends on third-party tools for this.
- Redis

#### Fail alert tools

four major points of failure when it comes to microservices

- Performance - New Relic and Datadog
- Build - Jenkins, Travis
- Components - Nagios and Zabbix are also very useful for making aid work to health check endpoints.
- Implementation failures - Sentry
  - See the impact of new deployments in real time
  - Provide support to specific users interrupted by an error
  - Detect and thwart fraud as it's attempted: unusual amounts of failures on purchases, authentication, and other critical areas
  - External integrations

### Locale proof performance

- Apache Benchmark
- WRK
- Locust

## Internal Patterns

### Developing the structure

### Caching strategies

### CQRS – query strategy

### Event sourcing – data integrity
