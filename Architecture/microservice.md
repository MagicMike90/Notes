# Microservice notes

## Domain-drive design

It is very important to note that OOP is not only inheritance, interfaces, or anything else of the type. OOP's main ideas are as follows:

- Code alignment with the business
- Favoring of reuse
- Minimal coupling

three are more prominent for efficient microservices:

- Context maps: These are the communication paths between microservices with appropriate interactions between microservices teams. After the analysis of the areas are already defined, the team can choose to be dependent on another team for domain language.
- Anti-corruption layer (ACL): This is the function that translates foreign concepts for an internal model to provide loose coupling between the domains.
- Interchange context: This provides an environment for both teams and discusses the meaning of each foreign term and translates the languages of microservices.

## Independent deploy, update, scale and replace

### Update

- Never share libraries between microservices
- Strong delimitation of microservice domains
- Establish a client-server relationship between microservices
- Deploy in separate containers

### Scale

**The Scale Cube**: 3 axis

- x-axis: horizontal decomposition: with the same application server replicated n times in full and in a balanced order of 1/n.
- y-axis: functional decomposition: a verb or route is used by the balancer to identify where to go with the request.
- z-axis: data partitioning: is very similar to the x-axis when it comes to scalability structure, as it distributes exactly the same code on each server. The big difference is that each server responds to a specific subset of dat

## Communication

|              |       One-to-One        |             One-to-Many |
| ------------ | :---------------------: | ----------------------: |
| Synchronous  |    Request/response     |                       - |
| Asymchronous |      Notification       |        publish/subsribe |
|              | Request/ async response | publish/async responses |

### Synchronous

- HTTP
- TCP
- WebSockets
- Sockets
- RPC
- SOAP

### Asynchronous

For this approach, the message broker is just perfect. Some software applications appear a good choice for message brokers, such as RabbitMQ, ActiveMQ, ZeroMQ, Kafka, and Redis. Each of these options has its own peculiarities, some are faster, others are more resilient. Again, the business setting is going to determine which technology is used.

### Mobile vs web endpoints

Problems such as speed and weight information in the web world are not very common; we cannot say the same for the mobile world.

### Caching at the client level

request only passes to be processed on the backend, if really necessary. In other words, it tries to block direct access to the backend to requests that have already been implemented in the recent past.

### Throttling for your client

- Number of requests per minute from the same client
- Number of requests per second from the same client
- Number of requests per minute from the same client for similar information
- Number of requests per second for the same client for the same information

### Identification of an anemic domain

- The microservice cannot perform the tasks itself with only the data received
- The microservice needs to fetch data in more than one endpoint to perform a task
- The microservice does not have a self-sufficient entity model
- The microservice waits for the completion of a task in another microservice to follow up what you need to do
- The microservice needs to share resources with other external microservices; these resources can be cached to the sample database

If the microservice being developed is one of those items, then it can be a weak area. If a microservice has two or more characteristics of those listed, then it is definitely an anemic domain.

Anemic domains are very harmful to the microservices ecosystem, because they have a tendency to be multiplied in order to correct the technical debt generated by the deficiency in the composition of their respective domains.

### Fat domain - AAA (Authentication, Authorization, and Accounting

The division of this fat domain can be held in two parts; the first part is AAAService and the second is UserService. Another approach is the AAA responsibility for a gateway API. The functional scalability and features of implementation with these separate domains is much more interesting for the growth of the product as a whol
